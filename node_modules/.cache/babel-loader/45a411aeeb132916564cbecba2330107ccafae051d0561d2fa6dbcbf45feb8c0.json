{"ast":null,"code":"// ============================================\n// FLASHCARD ALGORITHM - SM-2 (Simplified)\n// ============================================\n// Spaced repetition algorithm for optimal learning\n\n/**\n * Add days to a date\n */\nfunction addDays(date, days) {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result.toISOString().split('T')[0];\n}\n\n/**\n * Update card state based on rating (SM-2 algorithm)\n * @param {Object} card - Current card state\n * @param {string} rating - 'hard', 'good', or 'easy'\n * @returns {Object} Updated card state\n */\nexport function updateCard(card, rating) {\n  const now = new Date().toISOString();\n  const today = now.split('T')[0];\n  const updatedCard = {\n    ...card\n  };\n\n  // Update rating counts\n  if (rating === 'hard') {\n    updatedCard.timesHard += 1;\n  } else if (rating === 'good') {\n    updatedCard.timesGood += 1;\n  } else if (rating === 'easy') {\n    updatedCard.timesEasy += 1;\n  }\n\n  // SM-2 Algorithm logic\n  if (rating === 'hard') {\n    // Reset progress but don't completely restart\n    updatedCard.repetitions = 0;\n    updatedCard.interval = 1; // Review tomorrow\n    updatedCard.ease = Math.max(1.3, updatedCard.ease - 0.2);\n    updatedCard.state = 'learning';\n  } else {\n    // Good or Easy response\n    updatedCard.repetitions += 1;\n\n    // Calculate new interval\n    if (updatedCard.repetitions === 1) {\n      updatedCard.interval = 1; // 1 day\n    } else if (updatedCard.repetitions === 2) {\n      updatedCard.interval = 3; // 3 days\n    } else {\n      // Multiply previous interval by ease factor\n      updatedCard.interval = Math.round(updatedCard.interval * updatedCard.ease);\n    }\n\n    // Adjust ease factor\n    if (rating === 'easy') {\n      updatedCard.ease = Math.min(3.0, updatedCard.ease + 0.15);\n      // Bonus: Graduate faster on easy\n      if (updatedCard.repetitions === 1) {\n        updatedCard.interval = 3; // Skip ahead\n      }\n    } else if (rating === 'good') {\n      // Maintain ease factor (could add small adjustment if desired)\n      updatedCard.ease = Math.min(2.8, updatedCard.ease + 0.05);\n    }\n\n    // Update state based on repetitions\n    if (updatedCard.repetitions >= 2) {\n      updatedCard.state = 'review';\n    } else {\n      updatedCard.state = 'learning';\n    }\n  }\n\n  // Set due date\n  updatedCard.dueDate = addDays(today, updatedCard.interval);\n  updatedCard.lastReviewed = now;\n  return updatedCard;\n}\n\n/**\n * Select cards for a study session\n * @param {Array} allCards - All available cards\n * @param {Object} cardStates - Card states from storage\n * @param {number} sessionSize - Desired number of cards\n * @returns {Array} Cards to study\n */\nexport function selectCardsForSession(allCards, cardStates, sessionSize) {\n  const today = new Date().toISOString().split('T')[0];\n\n  // Categorize cards\n  const dueCards = [];\n  const newCards = [];\n  allCards.forEach(card => {\n    const state = cardStates[card.id];\n    if (!state || state.state === 'new') {\n      newCards.push({\n        ...card,\n        cardState: state || null\n      });\n    } else if (state.dueDate <= today) {\n      dueCards.push({\n        ...card,\n        cardState: state\n      });\n    }\n  });\n\n  // Sort due cards by date (oldest first)\n  dueCards.sort((a, b) => {\n    const dateA = new Date(a.cardState.dueDate);\n    const dateB = new Date(b.cardState.dueDate);\n    return dateA - dateB;\n  });\n\n  // If no due cards and no new cards, return empty\n  if (dueCards.length === 0 && newCards.length === 0) {\n    return [];\n  }\n\n  // Calculate distribution\n  const totalAvailable = dueCards.length + newCards.length;\n  const actualSessionSize = Math.min(sessionSize, totalAvailable);\n  let selectedCards = [];\n  if (sessionSize === Infinity) {\n    // \"Clear Everything\" mode - all due cards + some new\n    selectedCards = [...dueCards];\n    const remainingSlots = Math.min(50, newCards.length); // Cap new cards at 50 for sanity\n    selectedCards.push(...newCards.slice(0, remainingSlots));\n  } else {\n    // Calculate proportional distribution\n    const dueRatio = dueCards.length / totalAvailable;\n    const dueCount = Math.min(Math.round(actualSessionSize * dueRatio), dueCards.length);\n    const newCount = actualSessionSize - dueCount;\n    selectedCards = [...dueCards.slice(0, dueCount), ...newCards.slice(0, newCount)];\n  }\n\n  // Shuffle selected cards\n  for (let i = selectedCards.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [selectedCards[i], selectedCards[j]] = [selectedCards[j], selectedCards[i]];\n  }\n  return selectedCards;\n}\n\n/**\n * Calculate session statistics\n * @param {Array} ratings - Array of ratings from the session\n * @returns {Object} Session statistics\n */\nexport function calculateSessionStats(ratings) {\n  const stats = {\n    totalCards: ratings.length,\n    hardCount: ratings.filter(r => r === 'hard').length,\n    goodCount: ratings.filter(r => r === 'good').length,\n    easyCount: ratings.filter(r => r === 'easy').length\n  };\n  return stats;\n}","map":{"version":3,"names":["addDays","date","days","result","Date","setDate","getDate","toISOString","split","updateCard","card","rating","now","today","updatedCard","timesHard","timesGood","timesEasy","repetitions","interval","ease","Math","max","state","round","min","dueDate","lastReviewed","selectCardsForSession","allCards","cardStates","sessionSize","dueCards","newCards","forEach","id","push","cardState","sort","a","b","dateA","dateB","length","totalAvailable","actualSessionSize","selectedCards","Infinity","remainingSlots","slice","dueRatio","dueCount","newCount","i","j","floor","random","calculateSessionStats","ratings","stats","totalCards","hardCount","filter","r","goodCount","easyCount"],"sources":["C:/Users/Owner/certifystack/src/utils/flashcardAlgorithm.js"],"sourcesContent":["// ============================================\n// FLASHCARD ALGORITHM - SM-2 (Simplified)\n// ============================================\n// Spaced repetition algorithm for optimal learning\n\n/**\n * Add days to a date\n */\nfunction addDays(date, days) {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result.toISOString().split('T')[0];\n}\n\n/**\n * Update card state based on rating (SM-2 algorithm)\n * @param {Object} card - Current card state\n * @param {string} rating - 'hard', 'good', or 'easy'\n * @returns {Object} Updated card state\n */\nexport function updateCard(card, rating) {\n  const now = new Date().toISOString();\n  const today = now.split('T')[0];\n  const updatedCard = { ...card };\n\n  // Update rating counts\n  if (rating === 'hard') {\n    updatedCard.timesHard += 1;\n  } else if (rating === 'good') {\n    updatedCard.timesGood += 1;\n  } else if (rating === 'easy') {\n    updatedCard.timesEasy += 1;\n  }\n\n  // SM-2 Algorithm logic\n  if (rating === 'hard') {\n    // Reset progress but don't completely restart\n    updatedCard.repetitions = 0;\n    updatedCard.interval = 1; // Review tomorrow\n    updatedCard.ease = Math.max(1.3, updatedCard.ease - 0.2);\n    updatedCard.state = 'learning';\n  } else {\n    // Good or Easy response\n    updatedCard.repetitions += 1;\n\n    // Calculate new interval\n    if (updatedCard.repetitions === 1) {\n      updatedCard.interval = 1; // 1 day\n    } else if (updatedCard.repetitions === 2) {\n      updatedCard.interval = 3; // 3 days\n    } else {\n      // Multiply previous interval by ease factor\n      updatedCard.interval = Math.round(updatedCard.interval * updatedCard.ease);\n    }\n\n    // Adjust ease factor\n    if (rating === 'easy') {\n      updatedCard.ease = Math.min(3.0, updatedCard.ease + 0.15);\n      // Bonus: Graduate faster on easy\n      if (updatedCard.repetitions === 1) {\n        updatedCard.interval = 3; // Skip ahead\n      }\n    } else if (rating === 'good') {\n      // Maintain ease factor (could add small adjustment if desired)\n      updatedCard.ease = Math.min(2.8, updatedCard.ease + 0.05);\n    }\n\n    // Update state based on repetitions\n    if (updatedCard.repetitions >= 2) {\n      updatedCard.state = 'review';\n    } else {\n      updatedCard.state = 'learning';\n    }\n  }\n\n  // Set due date\n  updatedCard.dueDate = addDays(today, updatedCard.interval);\n  updatedCard.lastReviewed = now;\n\n  return updatedCard;\n}\n\n/**\n * Select cards for a study session\n * @param {Array} allCards - All available cards\n * @param {Object} cardStates - Card states from storage\n * @param {number} sessionSize - Desired number of cards\n * @returns {Array} Cards to study\n */\nexport function selectCardsForSession(allCards, cardStates, sessionSize) {\n  const today = new Date().toISOString().split('T')[0];\n\n  // Categorize cards\n  const dueCards = [];\n  const newCards = [];\n\n  allCards.forEach(card => {\n    const state = cardStates[card.id];\n\n    if (!state || state.state === 'new') {\n      newCards.push({ ...card, cardState: state || null });\n    } else if (state.dueDate <= today) {\n      dueCards.push({ ...card, cardState: state });\n    }\n  });\n\n  // Sort due cards by date (oldest first)\n  dueCards.sort((a, b) => {\n    const dateA = new Date(a.cardState.dueDate);\n    const dateB = new Date(b.cardState.dueDate);\n    return dateA - dateB;\n  });\n\n  // If no due cards and no new cards, return empty\n  if (dueCards.length === 0 && newCards.length === 0) {\n    return [];\n  }\n\n  // Calculate distribution\n  const totalAvailable = dueCards.length + newCards.length;\n  const actualSessionSize = Math.min(sessionSize, totalAvailable);\n\n  let selectedCards = [];\n\n  if (sessionSize === Infinity) {\n    // \"Clear Everything\" mode - all due cards + some new\n    selectedCards = [...dueCards];\n    const remainingSlots = Math.min(50, newCards.length); // Cap new cards at 50 for sanity\n    selectedCards.push(...newCards.slice(0, remainingSlots));\n  } else {\n    // Calculate proportional distribution\n    const dueRatio = dueCards.length / totalAvailable;\n    const dueCount = Math.min(\n      Math.round(actualSessionSize * dueRatio),\n      dueCards.length\n    );\n    const newCount = actualSessionSize - dueCount;\n\n    selectedCards = [\n      ...dueCards.slice(0, dueCount),\n      ...newCards.slice(0, newCount)\n    ];\n  }\n\n  // Shuffle selected cards\n  for (let i = selectedCards.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [selectedCards[i], selectedCards[j]] = [selectedCards[j], selectedCards[i]];\n  }\n\n  return selectedCards;\n}\n\n/**\n * Calculate session statistics\n * @param {Array} ratings - Array of ratings from the session\n * @returns {Object} Session statistics\n */\nexport function calculateSessionStats(ratings) {\n  const stats = {\n    totalCards: ratings.length,\n    hardCount: ratings.filter(r => r === 'hard').length,\n    goodCount: ratings.filter(r => r === 'good').length,\n    easyCount: ratings.filter(r => r === 'easy').length\n  };\n\n  return stats;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}