{"ast":null,"code":"import { htmlDecodeTree } from \"./generated/decode-data-html.js\";\nimport { xmlDecodeTree } from \"./generated/decode-data-xml.js\";\nimport { replaceCodePoint, fromCodePoint } from \"./decode-codepoint.js\";\nvar CharCodes;\n(function (CharCodes) {\n  CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n  CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n  CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n  CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n  CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n  CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n  CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n  CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n  CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n  CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n  CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n  CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nconst TO_LOWER_BIT = 32;\nexport var BinTrieFlags;\n(function (BinTrieFlags) {\n  BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags || (BinTrieFlags = {}));\nfunction isNumber(code) {\n  return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\nfunction isHexadecimalCharacter(code) {\n  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;\n}\nfunction isAsciiAlphaNumeric(code) {\n  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code) {\n  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\nvar EntityDecoderState;\n(function (EntityDecoderState) {\n  EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n  EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n  EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n  EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n  EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\nexport var DecodingMode;\n(function (DecodingMode) {\n  /** Entities in text nodes that can end with any character. */\n  DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n  /** Only allow entities terminated with a semicolon. */\n  DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n  /** Entities in attributes have limitations on ending characters. */\n  DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode || (DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\nexport class EntityDecoder {\n  constructor(/** The tree used to decode entities. */\n  decodeTree,\n  /**\n   * The function that is called when a codepoint is decoded.\n   *\n   * For multi-byte named entities, this will be called multiple times,\n   * with the second codepoint, and the same `consumed` value.\n   *\n   * @param codepoint The decoded codepoint.\n   * @param consumed The number of bytes consumed by the decoder.\n   */\n  emitCodePoint, /** An object that is used to produce errors. */\n  errors) {\n    this.decodeTree = decodeTree;\n    this.emitCodePoint = emitCodePoint;\n    this.errors = errors;\n    /** The current state of the decoder. */\n    this.state = EntityDecoderState.EntityStart;\n    /** Characters that were consumed while parsing an entity. */\n    this.consumed = 1;\n    /**\n     * The result of the entity.\n     *\n     * Either the result index of a numeric entity, or the codepoint of a\n     * numeric entity.\n     */\n    this.result = 0;\n    /** The current index in the decode tree. */\n    this.treeIndex = 0;\n    /** The number of characters that were consumed in excess. */\n    this.excess = 1;\n    /** The mode in which the decoder is operating. */\n    this.decodeMode = DecodingMode.Strict;\n  }\n  /** Resets the instance to make it reusable. */\n  startEntity(decodeMode) {\n    this.decodeMode = decodeMode;\n    this.state = EntityDecoderState.EntityStart;\n    this.result = 0;\n    this.treeIndex = 0;\n    this.excess = 1;\n    this.consumed = 1;\n  }\n  /**\n   * Write an entity to the decoder. This can be called multiple times with partial entities.\n   * If the entity is incomplete, the decoder will return -1.\n   *\n   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n   * entity is incomplete, and resume when the next string is written.\n   *\n   * @param input The string containing the entity (or a continuation of the entity).\n   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  write(input, offset) {\n    switch (this.state) {\n      case EntityDecoderState.EntityStart:\n        {\n          if (input.charCodeAt(offset) === CharCodes.NUM) {\n            this.state = EntityDecoderState.NumericStart;\n            this.consumed += 1;\n            return this.stateNumericStart(input, offset + 1);\n          }\n          this.state = EntityDecoderState.NamedEntity;\n          return this.stateNamedEntity(input, offset);\n        }\n      case EntityDecoderState.NumericStart:\n        {\n          return this.stateNumericStart(input, offset);\n        }\n      case EntityDecoderState.NumericDecimal:\n        {\n          return this.stateNumericDecimal(input, offset);\n        }\n      case EntityDecoderState.NumericHex:\n        {\n          return this.stateNumericHex(input, offset);\n        }\n      case EntityDecoderState.NamedEntity:\n        {\n          return this.stateNamedEntity(input, offset);\n        }\n    }\n  }\n  /**\n   * Switches between the numeric decimal and hexadecimal states.\n   *\n   * Equivalent to the `Numeric character reference state` in the HTML spec.\n   *\n   * @param input The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNumericStart(input, offset) {\n    if (offset >= input.length) {\n      return -1;\n    }\n    if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n      this.state = EntityDecoderState.NumericHex;\n      this.consumed += 1;\n      return this.stateNumericHex(input, offset + 1);\n    }\n    this.state = EntityDecoderState.NumericDecimal;\n    return this.stateNumericDecimal(input, offset);\n  }\n  addToNumericResult(input, start, end, base) {\n    if (start !== end) {\n      const digitCount = end - start;\n      this.result = this.result * Math.pow(base, digitCount) + Number.parseInt(input.substr(start, digitCount), base);\n      this.consumed += digitCount;\n    }\n  }\n  /**\n   * Parses a hexadecimal numeric entity.\n   *\n   * Equivalent to the `Hexademical character reference state` in the HTML spec.\n   *\n   * @param input The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNumericHex(input, offset) {\n    const startIndex = offset;\n    while (offset < input.length) {\n      const char = input.charCodeAt(offset);\n      if (isNumber(char) || isHexadecimalCharacter(char)) {\n        offset += 1;\n      } else {\n        this.addToNumericResult(input, startIndex, offset, 16);\n        return this.emitNumericEntity(char, 3);\n      }\n    }\n    this.addToNumericResult(input, startIndex, offset, 16);\n    return -1;\n  }\n  /**\n   * Parses a decimal numeric entity.\n   *\n   * Equivalent to the `Decimal character reference state` in the HTML spec.\n   *\n   * @param input The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNumericDecimal(input, offset) {\n    const startIndex = offset;\n    while (offset < input.length) {\n      const char = input.charCodeAt(offset);\n      if (isNumber(char)) {\n        offset += 1;\n      } else {\n        this.addToNumericResult(input, startIndex, offset, 10);\n        return this.emitNumericEntity(char, 2);\n      }\n    }\n    this.addToNumericResult(input, startIndex, offset, 10);\n    return -1;\n  }\n  /**\n   * Validate and emit a numeric entity.\n   *\n   * Implements the logic from the `Hexademical character reference start\n   * state` and `Numeric character reference end state` in the HTML spec.\n   *\n   * @param lastCp The last code point of the entity. Used to see if the\n   *               entity was terminated with a semicolon.\n   * @param expectedLength The minimum number of characters that should be\n   *                       consumed. Used to validate that at least one digit\n   *                       was consumed.\n   * @returns The number of characters that were consumed.\n   */\n  emitNumericEntity(lastCp, expectedLength) {\n    var _a;\n    // Ensure we consumed at least one digit.\n    if (this.consumed <= expectedLength) {\n      (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n      return 0;\n    }\n    // Figure out if this is a legit end of the entity\n    if (lastCp === CharCodes.SEMI) {\n      this.consumed += 1;\n    } else if (this.decodeMode === DecodingMode.Strict) {\n      return 0;\n    }\n    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);\n    if (this.errors) {\n      if (lastCp !== CharCodes.SEMI) {\n        this.errors.missingSemicolonAfterCharacterReference();\n      }\n      this.errors.validateNumericCharacterReference(this.result);\n    }\n    return this.consumed;\n  }\n  /**\n   * Parses a named entity.\n   *\n   * Equivalent to the `Named character reference state` in the HTML spec.\n   *\n   * @param input The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNamedEntity(input, offset) {\n    const {\n      decodeTree\n    } = this;\n    let current = decodeTree[this.treeIndex];\n    // The mask is the number of bytes of the value, including the current byte.\n    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n    for (; offset < input.length; offset++, this.excess++) {\n      const char = input.charCodeAt(offset);\n      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n      if (this.treeIndex < 0) {\n        return this.result === 0 ||\n        // If we are parsing an attribute\n        this.decodeMode === DecodingMode.Attribute && (\n        // We shouldn't have consumed any characters after the entity,\n        valueLength === 0 ||\n        // And there should be no invalid characters.\n        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();\n      }\n      current = decodeTree[this.treeIndex];\n      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n      // If the branch is a value, store it and continue\n      if (valueLength !== 0) {\n        // If the entity is terminated by a semicolon, we are done.\n        if (char === CharCodes.SEMI) {\n          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n        }\n        // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n        if (this.decodeMode !== DecodingMode.Strict) {\n          this.result = this.treeIndex;\n          this.consumed += this.excess;\n          this.excess = 0;\n        }\n      }\n    }\n    return -1;\n  }\n  /**\n   * Emit a named entity that was not terminated with a semicolon.\n   *\n   * @returns The number of characters consumed.\n   */\n  emitNotTerminatedNamedEntity() {\n    var _a;\n    const {\n      result,\n      decodeTree\n    } = this;\n    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n    this.emitNamedEntityData(result, valueLength, this.consumed);\n    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n    return this.consumed;\n  }\n  /**\n   * Emit a named entity.\n   *\n   * @param result The index of the entity in the decode tree.\n   * @param valueLength The number of bytes in the entity.\n   * @param consumed The number of characters consumed.\n   *\n   * @returns The number of characters consumed.\n   */\n  emitNamedEntityData(result, valueLength, consumed) {\n    const {\n      decodeTree\n    } = this;\n    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);\n    if (valueLength === 3) {\n      // For multi-byte values, we need to emit the second byte.\n      this.emitCodePoint(decodeTree[result + 2], consumed);\n    }\n    return consumed;\n  }\n  /**\n   * Signal to the parser that the end of the input was reached.\n   *\n   * Remaining data will be emitted and relevant errors will be produced.\n   *\n   * @returns The number of characters consumed.\n   */\n  end() {\n    var _a;\n    switch (this.state) {\n      case EntityDecoderState.NamedEntity:\n        {\n          // Emit a named entity if we have one.\n          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;\n        }\n      // Otherwise, emit a numeric entity if we have one.\n      case EntityDecoderState.NumericDecimal:\n        {\n          return this.emitNumericEntity(0, 2);\n        }\n      case EntityDecoderState.NumericHex:\n        {\n          return this.emitNumericEntity(0, 3);\n        }\n      case EntityDecoderState.NumericStart:\n        {\n          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n          return 0;\n        }\n      case EntityDecoderState.EntityStart:\n        {\n          // Return 0 if we have no entity.\n          return 0;\n        }\n    }\n  }\n}\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree) {\n  let returnValue = \"\";\n  const decoder = new EntityDecoder(decodeTree, data => returnValue += fromCodePoint(data));\n  return function decodeWithTrie(input, decodeMode) {\n    let lastIndex = 0;\n    let offset = 0;\n    while ((offset = input.indexOf(\"&\", offset)) >= 0) {\n      returnValue += input.slice(lastIndex, offset);\n      decoder.startEntity(decodeMode);\n      const length = decoder.write(input,\n      // Skip the \"&\"\n      offset + 1);\n      if (length < 0) {\n        lastIndex = offset + decoder.end();\n        break;\n      }\n      lastIndex = offset + length;\n      // If `length` is 0, skip the current `&` and continue.\n      offset = length === 0 ? lastIndex + 1 : lastIndex;\n    }\n    const result = returnValue + input.slice(lastIndex);\n    // Make sure we don't keep a reference to the final string.\n    returnValue = \"\";\n    return result;\n  };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nexport function determineBranch(decodeTree, current, nodeIndex, char) {\n  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n  // Case 1: Single branch encoded in jump offset\n  if (branchCount === 0) {\n    return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;\n  }\n  // Case 2: Multiple branches encoded in jump table\n  if (jumpOffset) {\n    const value = char - jumpOffset;\n    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;\n  }\n  // Case 3: Multiple branches encoded in dictionary\n  // Binary search for the character.\n  let lo = nodeIndex;\n  let hi = lo + branchCount - 1;\n  while (lo <= hi) {\n    const mid = lo + hi >>> 1;\n    const midValue = decodeTree[mid];\n    if (midValue < char) {\n      lo = mid + 1;\n    } else if (midValue > char) {\n      hi = mid - 1;\n    } else {\n      return decodeTree[mid + branchCount];\n    }\n  }\n  return -1;\n}\nconst htmlDecoder = /* #__PURE__ */getDecoder(htmlDecodeTree);\nconst xmlDecoder = /* #__PURE__ */getDecoder(xmlDecodeTree);\n/**\n * Decodes an HTML string.\n *\n * @param htmlString The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nexport function decodeHTML(htmlString, mode = DecodingMode.Legacy) {\n  return htmlDecoder(htmlString, mode);\n}\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param htmlAttribute The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLAttribute(htmlAttribute) {\n  return htmlDecoder(htmlAttribute, DecodingMode.Attribute);\n}\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param htmlString The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLStrict(htmlString) {\n  return htmlDecoder(htmlString, DecodingMode.Strict);\n}\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param xmlString The string to decode.\n * @returns The decoded string.\n */\nexport function decodeXML(xmlString) {\n  return xmlDecoder(xmlString, DecodingMode.Strict);\n}\n// Re-export for use by eg. htmlparser2\nexport { htmlDecodeTree } from \"./generated/decode-data-html.js\";\nexport { xmlDecodeTree } from \"./generated/decode-data-xml.js\";\nexport { decodeCodePoint, replaceCodePoint, fromCodePoint } from \"./decode-codepoint.js\";","map":{"version":3,"names":["htmlDecodeTree","xmlDecodeTree","replaceCodePoint","fromCodePoint","CharCodes","TO_LOWER_BIT","BinTrieFlags","isNumber","code","ZERO","NINE","isHexadecimalCharacter","UPPER_A","UPPER_F","LOWER_A","LOWER_F","isAsciiAlphaNumeric","UPPER_Z","LOWER_Z","isEntityInAttributeInvalidEnd","EQUALS","EntityDecoderState","DecodingMode","EntityDecoder","constructor","decodeTree","emitCodePoint","errors","state","EntityStart","consumed","result","treeIndex","excess","decodeMode","Strict","startEntity","write","input","offset","charCodeAt","NUM","NumericStart","stateNumericStart","NamedEntity","stateNamedEntity","NumericDecimal","stateNumericDecimal","NumericHex","stateNumericHex","length","LOWER_X","addToNumericResult","start","end","base","digitCount","Math","pow","Number","parseInt","substr","startIndex","char","emitNumericEntity","lastCp","expectedLength","_a","absenceOfDigitsInNumericCharacterReference","SEMI","missingSemicolonAfterCharacterReference","validateNumericCharacterReference","current","valueLength","VALUE_LENGTH","determineBranch","max","Attribute","emitNotTerminatedNamedEntity","emitNamedEntityData","getDecoder","returnValue","decoder","data","decodeWithTrie","lastIndex","indexOf","slice","nodeIndex","branchCount","BRANCH_LENGTH","jumpOffset","JUMP_TABLE","value","lo","hi","mid","midValue","htmlDecoder","xmlDecoder","decodeHTML","htmlString","mode","Legacy","decodeHTMLAttribute","htmlAttribute","decodeHTMLStrict","decodeXML","xmlString","decodeCodePoint"],"sources":["C:\\Users\\Owner\\certifystack\\node_modules\\hast-util-raw\\node_modules\\entities\\src\\decode.ts"],"sourcesContent":["import { htmlDecodeTree } from \"./generated/decode-data-html.js\";\nimport { xmlDecodeTree } from \"./generated/decode-data-xml.js\";\nimport { replaceCodePoint, fromCodePoint } from \"./decode-codepoint.js\";\n\nconst enum CharCodes {\n    NUM = 35, // \"#\"\n    SEMI = 59, // \";\"\n    EQUALS = 61, // \"=\"\n    ZERO = 48, // \"0\"\n    NINE = 57, // \"9\"\n    LOWER_A = 97, // \"a\"\n    LOWER_F = 102, // \"f\"\n    LOWER_X = 120, // \"x\"\n    LOWER_Z = 122, // \"z\"\n    UPPER_A = 65, // \"A\"\n    UPPER_F = 70, // \"F\"\n    UPPER_Z = 90, // \"Z\"\n}\n\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nconst TO_LOWER_BIT = 0b10_0000;\n\nexport enum BinTrieFlags {\n    VALUE_LENGTH = 0b1100_0000_0000_0000,\n    BRANCH_LENGTH = 0b0011_1111_1000_0000,\n    JUMP_TABLE = 0b0000_0000_0111_1111,\n}\n\nfunction isNumber(code: number): boolean {\n    return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\n\nfunction isHexadecimalCharacter(code: number): boolean {\n    return (\n        (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F)\n    );\n}\n\nfunction isAsciiAlphaNumeric(code: number): boolean {\n    return (\n        (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||\n        isNumber(code)\n    );\n}\n\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code: number): boolean {\n    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\n\nconst enum EntityDecoderState {\n    EntityStart,\n    NumericStart,\n    NumericDecimal,\n    NumericHex,\n    NamedEntity,\n}\n\nexport enum DecodingMode {\n    /** Entities in text nodes that can end with any character. */\n    Legacy = 0,\n    /** Only allow entities terminated with a semicolon. */\n    Strict = 1,\n    /** Entities in attributes have limitations on ending characters. */\n    Attribute = 2,\n}\n\n/**\n * Producers for character reference errors as defined in the HTML spec.\n */\nexport interface EntityErrorProducer {\n    missingSemicolonAfterCharacterReference(): void;\n    absenceOfDigitsInNumericCharacterReference(\n        consumedCharacters: number,\n    ): void;\n    validateNumericCharacterReference(code: number): void;\n}\n\n/**\n * Token decoder with support of writing partial entities.\n */\nexport class EntityDecoder {\n    constructor(\n        /** The tree used to decode entities. */\n        private readonly decodeTree: Uint16Array,\n        /**\n         * The function that is called when a codepoint is decoded.\n         *\n         * For multi-byte named entities, this will be called multiple times,\n         * with the second codepoint, and the same `consumed` value.\n         *\n         * @param codepoint The decoded codepoint.\n         * @param consumed The number of bytes consumed by the decoder.\n         */\n        private readonly emitCodePoint: (cp: number, consumed: number) => void,\n        /** An object that is used to produce errors. */\n        private readonly errors?: EntityErrorProducer | undefined,\n    ) {}\n\n    /** The current state of the decoder. */\n    private state = EntityDecoderState.EntityStart;\n    /** Characters that were consumed while parsing an entity. */\n    private consumed = 1;\n    /**\n     * The result of the entity.\n     *\n     * Either the result index of a numeric entity, or the codepoint of a\n     * numeric entity.\n     */\n    private result = 0;\n\n    /** The current index in the decode tree. */\n    private treeIndex = 0;\n    /** The number of characters that were consumed in excess. */\n    private excess = 1;\n    /** The mode in which the decoder is operating. */\n    private decodeMode = DecodingMode.Strict;\n\n    /** Resets the instance to make it reusable. */\n    startEntity(decodeMode: DecodingMode): void {\n        this.decodeMode = decodeMode;\n        this.state = EntityDecoderState.EntityStart;\n        this.result = 0;\n        this.treeIndex = 0;\n        this.excess = 1;\n        this.consumed = 1;\n    }\n\n    /**\n     * Write an entity to the decoder. This can be called multiple times with partial entities.\n     * If the entity is incomplete, the decoder will return -1.\n     *\n     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n     * entity is incomplete, and resume when the next string is written.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    write(input: string, offset: number): number {\n        switch (this.state) {\n            case EntityDecoderState.EntityStart: {\n                if (input.charCodeAt(offset) === CharCodes.NUM) {\n                    this.state = EntityDecoderState.NumericStart;\n                    this.consumed += 1;\n                    return this.stateNumericStart(input, offset + 1);\n                }\n                this.state = EntityDecoderState.NamedEntity;\n                return this.stateNamedEntity(input, offset);\n            }\n\n            case EntityDecoderState.NumericStart: {\n                return this.stateNumericStart(input, offset);\n            }\n\n            case EntityDecoderState.NumericDecimal: {\n                return this.stateNumericDecimal(input, offset);\n            }\n\n            case EntityDecoderState.NumericHex: {\n                return this.stateNumericHex(input, offset);\n            }\n\n            case EntityDecoderState.NamedEntity: {\n                return this.stateNamedEntity(input, offset);\n            }\n        }\n    }\n\n    /**\n     * Switches between the numeric decimal and hexadecimal states.\n     *\n     * Equivalent to the `Numeric character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    private stateNumericStart(input: string, offset: number): number {\n        if (offset >= input.length) {\n            return -1;\n        }\n\n        if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n            this.state = EntityDecoderState.NumericHex;\n            this.consumed += 1;\n            return this.stateNumericHex(input, offset + 1);\n        }\n\n        this.state = EntityDecoderState.NumericDecimal;\n        return this.stateNumericDecimal(input, offset);\n    }\n\n    private addToNumericResult(\n        input: string,\n        start: number,\n        end: number,\n        base: number,\n    ): void {\n        if (start !== end) {\n            const digitCount = end - start;\n            this.result =\n                this.result * Math.pow(base, digitCount) +\n                Number.parseInt(input.substr(start, digitCount), base);\n            this.consumed += digitCount;\n        }\n    }\n\n    /**\n     * Parses a hexadecimal numeric entity.\n     *\n     * Equivalent to the `Hexademical character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    private stateNumericHex(input: string, offset: number): number {\n        const startIndex = offset;\n\n        while (offset < input.length) {\n            const char = input.charCodeAt(offset);\n            if (isNumber(char) || isHexadecimalCharacter(char)) {\n                offset += 1;\n            } else {\n                this.addToNumericResult(input, startIndex, offset, 16);\n                return this.emitNumericEntity(char, 3);\n            }\n        }\n\n        this.addToNumericResult(input, startIndex, offset, 16);\n\n        return -1;\n    }\n\n    /**\n     * Parses a decimal numeric entity.\n     *\n     * Equivalent to the `Decimal character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    private stateNumericDecimal(input: string, offset: number): number {\n        const startIndex = offset;\n\n        while (offset < input.length) {\n            const char = input.charCodeAt(offset);\n            if (isNumber(char)) {\n                offset += 1;\n            } else {\n                this.addToNumericResult(input, startIndex, offset, 10);\n                return this.emitNumericEntity(char, 2);\n            }\n        }\n\n        this.addToNumericResult(input, startIndex, offset, 10);\n\n        return -1;\n    }\n\n    /**\n     * Validate and emit a numeric entity.\n     *\n     * Implements the logic from the `Hexademical character reference start\n     * state` and `Numeric character reference end state` in the HTML spec.\n     *\n     * @param lastCp The last code point of the entity. Used to see if the\n     *               entity was terminated with a semicolon.\n     * @param expectedLength The minimum number of characters that should be\n     *                       consumed. Used to validate that at least one digit\n     *                       was consumed.\n     * @returns The number of characters that were consumed.\n     */\n    private emitNumericEntity(lastCp: number, expectedLength: number): number {\n        // Ensure we consumed at least one digit.\n        if (this.consumed <= expectedLength) {\n            this.errors?.absenceOfDigitsInNumericCharacterReference(\n                this.consumed,\n            );\n            return 0;\n        }\n\n        // Figure out if this is a legit end of the entity\n        if (lastCp === CharCodes.SEMI) {\n            this.consumed += 1;\n        } else if (this.decodeMode === DecodingMode.Strict) {\n            return 0;\n        }\n\n        this.emitCodePoint(replaceCodePoint(this.result), this.consumed);\n\n        if (this.errors) {\n            if (lastCp !== CharCodes.SEMI) {\n                this.errors.missingSemicolonAfterCharacterReference();\n            }\n\n            this.errors.validateNumericCharacterReference(this.result);\n        }\n\n        return this.consumed;\n    }\n\n    /**\n     * Parses a named entity.\n     *\n     * Equivalent to the `Named character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    private stateNamedEntity(input: string, offset: number): number {\n        const { decodeTree } = this;\n        let current = decodeTree[this.treeIndex];\n        // The mask is the number of bytes of the value, including the current byte.\n        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n\n        for (; offset < input.length; offset++, this.excess++) {\n            const char = input.charCodeAt(offset);\n\n            this.treeIndex = determineBranch(\n                decodeTree,\n                current,\n                this.treeIndex + Math.max(1, valueLength),\n                char,\n            );\n\n            if (this.treeIndex < 0) {\n                return this.result === 0 ||\n                    // If we are parsing an attribute\n                    (this.decodeMode === DecodingMode.Attribute &&\n                        // We shouldn't have consumed any characters after the entity,\n                        (valueLength === 0 ||\n                            // And there should be no invalid characters.\n                            isEntityInAttributeInvalidEnd(char)))\n                    ? 0\n                    : this.emitNotTerminatedNamedEntity();\n            }\n\n            current = decodeTree[this.treeIndex];\n            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n\n            // If the branch is a value, store it and continue\n            if (valueLength !== 0) {\n                // If the entity is terminated by a semicolon, we are done.\n                if (char === CharCodes.SEMI) {\n                    return this.emitNamedEntityData(\n                        this.treeIndex,\n                        valueLength,\n                        this.consumed + this.excess,\n                    );\n                }\n\n                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n                if (this.decodeMode !== DecodingMode.Strict) {\n                    this.result = this.treeIndex;\n                    this.consumed += this.excess;\n                    this.excess = 0;\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Emit a named entity that was not terminated with a semicolon.\n     *\n     * @returns The number of characters consumed.\n     */\n    private emitNotTerminatedNamedEntity(): number {\n        const { result, decodeTree } = this;\n\n        const valueLength =\n            (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n\n        this.emitNamedEntityData(result, valueLength, this.consumed);\n        this.errors?.missingSemicolonAfterCharacterReference();\n\n        return this.consumed;\n    }\n\n    /**\n     * Emit a named entity.\n     *\n     * @param result The index of the entity in the decode tree.\n     * @param valueLength The number of bytes in the entity.\n     * @param consumed The number of characters consumed.\n     *\n     * @returns The number of characters consumed.\n     */\n    private emitNamedEntityData(\n        result: number,\n        valueLength: number,\n        consumed: number,\n    ): number {\n        const { decodeTree } = this;\n\n        this.emitCodePoint(\n            valueLength === 1\n                ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH\n                : decodeTree[result + 1],\n            consumed,\n        );\n        if (valueLength === 3) {\n            // For multi-byte values, we need to emit the second byte.\n            this.emitCodePoint(decodeTree[result + 2], consumed);\n        }\n\n        return consumed;\n    }\n\n    /**\n     * Signal to the parser that the end of the input was reached.\n     *\n     * Remaining data will be emitted and relevant errors will be produced.\n     *\n     * @returns The number of characters consumed.\n     */\n    end(): number {\n        switch (this.state) {\n            case EntityDecoderState.NamedEntity: {\n                // Emit a named entity if we have one.\n                return this.result !== 0 &&\n                    (this.decodeMode !== DecodingMode.Attribute ||\n                        this.result === this.treeIndex)\n                    ? this.emitNotTerminatedNamedEntity()\n                    : 0;\n            }\n            // Otherwise, emit a numeric entity if we have one.\n            case EntityDecoderState.NumericDecimal: {\n                return this.emitNumericEntity(0, 2);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.emitNumericEntity(0, 3);\n            }\n            case EntityDecoderState.NumericStart: {\n                this.errors?.absenceOfDigitsInNumericCharacterReference(\n                    this.consumed,\n                );\n                return 0;\n            }\n            case EntityDecoderState.EntityStart: {\n                // Return 0 if we have no entity.\n                return 0;\n            }\n        }\n    }\n}\n\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree: Uint16Array) {\n    let returnValue = \"\";\n    const decoder = new EntityDecoder(\n        decodeTree,\n        (data) => (returnValue += fromCodePoint(data)),\n    );\n\n    return function decodeWithTrie(\n        input: string,\n        decodeMode: DecodingMode,\n    ): string {\n        let lastIndex = 0;\n        let offset = 0;\n\n        while ((offset = input.indexOf(\"&\", offset)) >= 0) {\n            returnValue += input.slice(lastIndex, offset);\n\n            decoder.startEntity(decodeMode);\n\n            const length = decoder.write(\n                input,\n                // Skip the \"&\"\n                offset + 1,\n            );\n\n            if (length < 0) {\n                lastIndex = offset + decoder.end();\n                break;\n            }\n\n            lastIndex = offset + length;\n            // If `length` is 0, skip the current `&` and continue.\n            offset = length === 0 ? lastIndex + 1 : lastIndex;\n        }\n\n        const result = returnValue + input.slice(lastIndex);\n\n        // Make sure we don't keep a reference to the final string.\n        returnValue = \"\";\n\n        return result;\n    };\n}\n\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nexport function determineBranch(\n    decodeTree: Uint16Array,\n    current: number,\n    nodeIndex: number,\n    char: number,\n): number {\n    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;\n    }\n\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        const value = char - jumpOffset;\n\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIndex + value] - 1;\n    }\n\n    // Case 3: Multiple branches encoded in dictionary\n\n    // Binary search for the character.\n    let lo = nodeIndex;\n    let hi = lo + branchCount - 1;\n\n    while (lo <= hi) {\n        const mid = (lo + hi) >>> 1;\n        const midValue = decodeTree[mid];\n\n        if (midValue < char) {\n            lo = mid + 1;\n        } else if (midValue > char) {\n            hi = mid - 1;\n        } else {\n            return decodeTree[mid + branchCount];\n        }\n    }\n\n    return -1;\n}\n\nconst htmlDecoder = /* #__PURE__ */ getDecoder(htmlDecodeTree);\nconst xmlDecoder = /* #__PURE__ */ getDecoder(xmlDecodeTree);\n\n/**\n * Decodes an HTML string.\n *\n * @param htmlString The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nexport function decodeHTML(\n    htmlString: string,\n    mode: DecodingMode = DecodingMode.Legacy,\n): string {\n    return htmlDecoder(htmlString, mode);\n}\n\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param htmlAttribute The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLAttribute(htmlAttribute: string): string {\n    return htmlDecoder(htmlAttribute, DecodingMode.Attribute);\n}\n\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param htmlString The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLStrict(htmlString: string): string {\n    return htmlDecoder(htmlString, DecodingMode.Strict);\n}\n\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param xmlString The string to decode.\n * @returns The decoded string.\n */\nexport function decodeXML(xmlString: string): string {\n    return xmlDecoder(xmlString, DecodingMode.Strict);\n}\n\n// Re-export for use by eg. htmlparser2\nexport { htmlDecodeTree } from \"./generated/decode-data-html.js\";\nexport { xmlDecodeTree } from \"./generated/decode-data-xml.js\";\n\nexport {\n    decodeCodePoint,\n    replaceCodePoint,\n    fromCodePoint,\n} from \"./decode-codepoint.js\";\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}