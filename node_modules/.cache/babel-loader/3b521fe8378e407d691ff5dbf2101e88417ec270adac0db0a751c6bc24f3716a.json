{"ast":null,"code":"/**\n * @import {VFile, Value} from 'vfile'\n * @import {Location} from 'vfile-location'\n */\n\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file);\n  /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */\n  const indices = [];\n  return {\n    toOffset,\n    toPoint\n  };\n\n  /** @type {Location['toPoint']} */\n  function toPoint(offset) {\n    if (typeof offset === 'number' && offset > -1 && offset <= value.length) {\n      let index = 0;\n      while (true) {\n        let end = indices[index];\n        if (end === undefined) {\n          const eol = next(value, indices[index - 1]);\n          end = eol === -1 ? value.length + 1 : eol + 1;\n          indices[index] = end;\n        }\n        if (end > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          };\n        }\n        index++;\n      }\n    }\n  }\n\n  /** @type {Location['toOffset']} */\n  function toOffset(point) {\n    if (point && typeof point.line === 'number' && typeof point.column === 'number' && !Number.isNaN(point.line) && !Number.isNaN(point.column)) {\n      while (indices.length < point.line) {\n        const from = indices[indices.length - 1];\n        const eol = next(value, from);\n        const end = eol === -1 ? value.length + 1 : eol + 1;\n        if (from === end) break;\n        indices.push(end);\n      }\n      const offset = (point.line > 1 ? indices[point.line - 2] : 0) + point.column - 1;\n      // The given `column` could not exist on this line.\n      if (offset < indices[point.line - 1]) return offset;\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @param {number} from\n */\nfunction next(value, from) {\n  const cr = value.indexOf('\\r', from);\n  const lf = value.indexOf('\\n', from);\n  if (lf === -1) return cr;\n  if (cr === -1 || cr + 1 === lf) return lf;\n  return cr < lf ? cr : lf;\n}","map":{"version":3,"names":["location","file","value","String","indices","toOffset","toPoint","offset","length","index","end","undefined","eol","next","line","column","point","Number","isNaN","from","push","cr","indexOf","lf"],"sources":["C:/Users/Owner/certifystack/node_modules/vfile-location/lib/index.js"],"sourcesContent":["/**\n * @import {VFile, Value} from 'vfile'\n * @import {Location} from 'vfile-location'\n */\n\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file)\n  /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */\n  const indices = []\n\n  return {toOffset, toPoint}\n\n  /** @type {Location['toPoint']} */\n  function toPoint(offset) {\n    if (typeof offset === 'number' && offset > -1 && offset <= value.length) {\n      let index = 0\n\n      while (true) {\n        let end = indices[index]\n\n        if (end === undefined) {\n          const eol = next(value, indices[index - 1])\n          end = eol === -1 ? value.length + 1 : eol + 1\n          indices[index] = end\n        }\n\n        if (end > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          }\n        }\n\n        index++\n      }\n    }\n  }\n\n  /** @type {Location['toOffset']} */\n  function toOffset(point) {\n    if (\n      point &&\n      typeof point.line === 'number' &&\n      typeof point.column === 'number' &&\n      !Number.isNaN(point.line) &&\n      !Number.isNaN(point.column)\n    ) {\n      while (indices.length < point.line) {\n        const from = indices[indices.length - 1]\n        const eol = next(value, from)\n        const end = eol === -1 ? value.length + 1 : eol + 1\n        if (from === end) break\n        indices.push(end)\n      }\n\n      const offset =\n        (point.line > 1 ? indices[point.line - 2] : 0) + point.column - 1\n      // The given `column` could not exist on this line.\n      if (offset < indices[point.line - 1]) return offset\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @param {number} from\n */\nfunction next(value, from) {\n  const cr = value.indexOf('\\r', from)\n  const lf = value.indexOf('\\n', from)\n  if (lf === -1) return cr\n  if (cr === -1 || cr + 1 === lf) return lf\n  return cr < lf ? cr : lf\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAQA,CAACC,IAAI,EAAE;EAC7B,MAAMC,KAAK,GAAGC,MAAM,CAACF,IAAI,CAAC;EAC1B;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,OAAO,GAAG,EAAE;EAElB,OAAO;IAACC,QAAQ;IAAEC;EAAO,CAAC;;EAE1B;EACA,SAASA,OAAOA,CAACC,MAAM,EAAE;IACvB,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,GAAG,CAAC,CAAC,IAAIA,MAAM,IAAIL,KAAK,CAACM,MAAM,EAAE;MACvE,IAAIC,KAAK,GAAG,CAAC;MAEb,OAAO,IAAI,EAAE;QACX,IAAIC,GAAG,GAAGN,OAAO,CAACK,KAAK,CAAC;QAExB,IAAIC,GAAG,KAAKC,SAAS,EAAE;UACrB,MAAMC,GAAG,GAAGC,IAAI,CAACX,KAAK,EAAEE,OAAO,CAACK,KAAK,GAAG,CAAC,CAAC,CAAC;UAC3CC,GAAG,GAAGE,GAAG,KAAK,CAAC,CAAC,GAAGV,KAAK,CAACM,MAAM,GAAG,CAAC,GAAGI,GAAG,GAAG,CAAC;UAC7CR,OAAO,CAACK,KAAK,CAAC,GAAGC,GAAG;QACtB;QAEA,IAAIA,GAAG,GAAGH,MAAM,EAAE;UAChB,OAAO;YACLO,IAAI,EAAEL,KAAK,GAAG,CAAC;YACfM,MAAM,EAAER,MAAM,IAAIE,KAAK,GAAG,CAAC,GAAGL,OAAO,CAACK,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;YACzDF;UACF,CAAC;QACH;QAEAE,KAAK,EAAE;MACT;IACF;EACF;;EAEA;EACA,SAASJ,QAAQA,CAACW,KAAK,EAAE;IACvB,IACEA,KAAK,IACL,OAAOA,KAAK,CAACF,IAAI,KAAK,QAAQ,IAC9B,OAAOE,KAAK,CAACD,MAAM,KAAK,QAAQ,IAChC,CAACE,MAAM,CAACC,KAAK,CAACF,KAAK,CAACF,IAAI,CAAC,IACzB,CAACG,MAAM,CAACC,KAAK,CAACF,KAAK,CAACD,MAAM,CAAC,EAC3B;MACA,OAAOX,OAAO,CAACI,MAAM,GAAGQ,KAAK,CAACF,IAAI,EAAE;QAClC,MAAMK,IAAI,GAAGf,OAAO,CAACA,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC;QACxC,MAAMI,GAAG,GAAGC,IAAI,CAACX,KAAK,EAAEiB,IAAI,CAAC;QAC7B,MAAMT,GAAG,GAAGE,GAAG,KAAK,CAAC,CAAC,GAAGV,KAAK,CAACM,MAAM,GAAG,CAAC,GAAGI,GAAG,GAAG,CAAC;QACnD,IAAIO,IAAI,KAAKT,GAAG,EAAE;QAClBN,OAAO,CAACgB,IAAI,CAACV,GAAG,CAAC;MACnB;MAEA,MAAMH,MAAM,GACV,CAACS,KAAK,CAACF,IAAI,GAAG,CAAC,GAAGV,OAAO,CAACY,KAAK,CAACF,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,IAAIE,KAAK,CAACD,MAAM,GAAG,CAAC;MACnE;MACA,IAAIR,MAAM,GAAGH,OAAO,CAACY,KAAK,CAACF,IAAI,GAAG,CAAC,CAAC,EAAE,OAAOP,MAAM;IACrD;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA,SAASM,IAAIA,CAACX,KAAK,EAAEiB,IAAI,EAAE;EACzB,MAAME,EAAE,GAAGnB,KAAK,CAACoB,OAAO,CAAC,IAAI,EAAEH,IAAI,CAAC;EACpC,MAAMI,EAAE,GAAGrB,KAAK,CAACoB,OAAO,CAAC,IAAI,EAAEH,IAAI,CAAC;EACpC,IAAII,EAAE,KAAK,CAAC,CAAC,EAAE,OAAOF,EAAE;EACxB,IAAIA,EAAE,KAAK,CAAC,CAAC,IAAIA,EAAE,GAAG,CAAC,KAAKE,EAAE,EAAE,OAAOA,EAAE;EACzC,OAAOF,EAAE,GAAGE,EAAE,GAAGF,EAAE,GAAGE,EAAE;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}