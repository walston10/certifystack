{"ast":null,"code":"import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport class Preprocessor {\n  constructor(handler) {\n    this.handler = handler;\n    this.html = '';\n    this.pos = -1;\n    // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n    this.lastGapPos = -2;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n    this.isEol = false;\n    this.lineStartPos = 0;\n    this.droppedBufferSize = 0;\n    this.line = 1;\n    //NOTE: avoid reporting errors twice on advance/retreat\n    this.lastErrOffset = -1;\n  }\n  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n  get col() {\n    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n  }\n  get offset() {\n    return this.droppedBufferSize + this.pos;\n  }\n  getError(code, cpOffset) {\n    const {\n      line,\n      col,\n      offset\n    } = this;\n    const startCol = col + cpOffset;\n    const startOffset = offset + cpOffset;\n    return {\n      code,\n      startLine: line,\n      endLine: line,\n      startCol,\n      endCol: startCol,\n      startOffset,\n      endOffset: startOffset\n    };\n  }\n  _err(code) {\n    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n      this.lastErrOffset = this.offset;\n      this.handler.onParseError(this.getError(code, 0));\n    }\n  }\n  _addGap() {\n    this.gapStack.push(this.lastGapPos);\n    this.lastGapPos = this.pos;\n  }\n  _processSurrogate(cp) {\n    //NOTE: try to peek a surrogate pair\n    if (this.pos !== this.html.length - 1) {\n      const nextCp = this.html.charCodeAt(this.pos + 1);\n      if (isSurrogatePair(nextCp)) {\n        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n        this.pos++;\n        //NOTE: add a gap that should be avoided during retreat\n        this._addGap();\n        return getSurrogatePairCodePoint(cp, nextCp);\n      }\n    }\n    //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n    else if (!this.lastChunkWritten) {\n      this.endOfChunkHit = true;\n      return $.EOF;\n    }\n    //NOTE: isolated surrogate\n    this._err(ERR.surrogateInInputStream);\n    return cp;\n  }\n  willDropParsedChunk() {\n    return this.pos > this.bufferWaterline;\n  }\n  dropParsedChunk() {\n    if (this.willDropParsedChunk()) {\n      this.html = this.html.substring(this.pos);\n      this.lineStartPos -= this.pos;\n      this.droppedBufferSize += this.pos;\n      this.pos = 0;\n      this.lastGapPos = -2;\n      this.gapStack.length = 0;\n    }\n  }\n  write(chunk, isLastChunk) {\n    if (this.html.length > 0) {\n      this.html += chunk;\n    } else {\n      this.html = chunk;\n    }\n    this.endOfChunkHit = false;\n    this.lastChunkWritten = isLastChunk;\n  }\n  insertHtmlAtCurrentPos(chunk) {\n    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n    this.endOfChunkHit = false;\n  }\n  startsWith(pattern, caseSensitive) {\n    // Check if our buffer has enough characters\n    if (this.pos + pattern.length > this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return false;\n    }\n    if (caseSensitive) {\n      return this.html.startsWith(pattern, this.pos);\n    }\n    for (let i = 0; i < pattern.length; i++) {\n      const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n      if (cp !== pattern.charCodeAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  peek(offset) {\n    const pos = this.pos + offset;\n    if (pos >= this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return $.EOF;\n    }\n    const code = this.html.charCodeAt(pos);\n    return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\n  }\n  advance() {\n    this.pos++;\n    //NOTE: LF should be in the last column of the line\n    if (this.isEol) {\n      this.isEol = false;\n      this.line++;\n      this.lineStartPos = this.pos;\n    }\n    if (this.pos >= this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return $.EOF;\n    }\n    let cp = this.html.charCodeAt(this.pos);\n    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n    if (cp === $.CARRIAGE_RETURN) {\n      this.isEol = true;\n      this.skipNextNewLine = true;\n      return $.LINE_FEED;\n    }\n    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n    //must be ignored.\n    if (cp === $.LINE_FEED) {\n      this.isEol = true;\n      if (this.skipNextNewLine) {\n        // `line` will be bumped again in the recursive call.\n        this.line--;\n        this.skipNextNewLine = false;\n        this._addGap();\n        return this.advance();\n      }\n    }\n    this.skipNextNewLine = false;\n    if (isSurrogate(cp)) {\n      cp = this._processSurrogate(cp);\n    }\n    //OPTIMIZATION: first check if code point is in the common allowed\n    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n    //before going into detailed performance cost validation.\n    const isCommonValidRange = this.handler.onParseError === null || cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 64976;\n    if (!isCommonValidRange) {\n      this._checkForProblematicCharacters(cp);\n    }\n    return cp;\n  }\n  _checkForProblematicCharacters(cp) {\n    if (isControlCodePoint(cp)) {\n      this._err(ERR.controlCharacterInInputStream);\n    } else if (isUndefinedCodePoint(cp)) {\n      this._err(ERR.noncharacterInInputStream);\n    }\n  }\n  retreat(count) {\n    this.pos -= count;\n    while (this.pos < this.lastGapPos) {\n      this.lastGapPos = this.gapStack.pop();\n      this.pos--;\n    }\n    this.isEol = false;\n  }\n}","map":{"version":3,"names":["CODE_POINTS","$","getSurrogatePairCodePoint","isControlCodePoint","isSurrogate","isSurrogatePair","isUndefinedCodePoint","ERR","DEFAULT_BUFFER_WATERLINE","Preprocessor","constructor","handler","html","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","isEol","lineStartPos","droppedBufferSize","line","lastErrOffset","col","Number","offset","getError","code","cpOffset","startCol","startOffset","startLine","endLine","endCol","endOffset","_err","onParseError","_addGap","push","_processSurrogate","cp","length","nextCp","charCodeAt","EOF","surrogateInInputStream","willDropParsedChunk","dropParsedChunk","substring","write","chunk","isLastChunk","insertHtmlAtCurrentPos","startsWith","pattern","caseSensitive","i","peek","CARRIAGE_RETURN","LINE_FEED","advance","isCommonValidRange","_checkForProblematicCharacters","controlCharacterInInputStream","noncharacterInInputStream","retreat","count","pop"],"sources":["C:/Users/Owner/certifystack/node_modules/hast-util-raw/node_modules/parse5/dist/tokenizer/preprocessor.js"],"sourcesContent":["import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint, } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport class Preprocessor {\n    constructor(handler) {\n        this.handler = handler;\n        this.html = '';\n        this.pos = -1;\n        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n        this.lastGapPos = -2;\n        this.gapStack = [];\n        this.skipNextNewLine = false;\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n        this.line = 1;\n        //NOTE: avoid reporting errors twice on advance/retreat\n        this.lastErrOffset = -1;\n    }\n    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n    get col() {\n        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n    get offset() {\n        return this.droppedBufferSize + this.pos;\n    }\n    getError(code, cpOffset) {\n        const { line, col, offset } = this;\n        const startCol = col + cpOffset;\n        const startOffset = offset + cpOffset;\n        return {\n            code,\n            startLine: line,\n            endLine: line,\n            startCol,\n            endCol: startCol,\n            startOffset,\n            endOffset: startOffset,\n        };\n    }\n    _err(code) {\n        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n            this.lastErrOffset = this.offset;\n            this.handler.onParseError(this.getError(code, 0));\n        }\n    }\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.html.length - 1) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n            if (isSurrogatePair(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n                //NOTE: add a gap that should be avoided during retreat\n                this._addGap();\n                return getSurrogatePairCodePoint(cp, nextCp);\n            }\n        }\n        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return $.EOF;\n        }\n        //NOTE: isolated surrogate\n        this._err(ERR.surrogateInInputStream);\n        return cp;\n    }\n    willDropParsedChunk() {\n        return this.pos > this.bufferWaterline;\n    }\n    dropParsedChunk() {\n        if (this.willDropParsedChunk()) {\n            this.html = this.html.substring(this.pos);\n            this.lineStartPos -= this.pos;\n            this.droppedBufferSize += this.pos;\n            this.pos = 0;\n            this.lastGapPos = -2;\n            this.gapStack.length = 0;\n        }\n    }\n    write(chunk, isLastChunk) {\n        if (this.html.length > 0) {\n            this.html += chunk;\n        }\n        else {\n            this.html = chunk;\n        }\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n        this.endOfChunkHit = false;\n    }\n    startsWith(pattern, caseSensitive) {\n        // Check if our buffer has enough characters\n        if (this.pos + pattern.length > this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return false;\n        }\n        if (caseSensitive) {\n            return this.html.startsWith(pattern, this.pos);\n        }\n        for (let i = 0; i < pattern.length; i++) {\n            const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n            if (cp !== pattern.charCodeAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    peek(offset) {\n        const pos = this.pos + offset;\n        if (pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        const code = this.html.charCodeAt(pos);\n        return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\n    }\n    advance() {\n        this.pos++;\n        //NOTE: LF should be in the last column of the line\n        if (this.isEol) {\n            this.isEol = false;\n            this.line++;\n            this.lineStartPos = this.pos;\n        }\n        if (this.pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        let cp = this.html.charCodeAt(this.pos);\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === $.CARRIAGE_RETURN) {\n            this.isEol = true;\n            this.skipNextNewLine = true;\n            return $.LINE_FEED;\n        }\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (cp === $.LINE_FEED) {\n            this.isEol = true;\n            if (this.skipNextNewLine) {\n                // `line` will be bumped again in the recursive call.\n                this.line--;\n                this.skipNextNewLine = false;\n                this._addGap();\n                return this.advance();\n            }\n        }\n        this.skipNextNewLine = false;\n        if (isSurrogate(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange = this.handler.onParseError === null ||\n            (cp > 0x1f && cp < 0x7f) ||\n            cp === $.LINE_FEED ||\n            cp === $.CARRIAGE_RETURN ||\n            (cp > 0x9f && cp < 64976);\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n        return cp;\n    }\n    _checkForProblematicCharacters(cp) {\n        if (isControlCodePoint(cp)) {\n            this._err(ERR.controlCharacterInInputStream);\n        }\n        else if (isUndefinedCodePoint(cp)) {\n            this._err(ERR.noncharacterInInputStream);\n        }\n    }\n    retreat(count) {\n        this.pos -= count;\n        while (this.pos < this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n        this.isEol = false;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}