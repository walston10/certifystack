{"ast":null,"code":"/**\n * @import {ElementData, Element, Nodes, RootContent, Root} from 'hast'\n * @import {DefaultTreeAdapterMap, Token} from 'parse5'\n * @import {Schema} from 'property-information'\n * @import {Point, Position} from 'unist'\n * @import {VFile} from 'vfile'\n * @import {Options} from 'hast-util-from-parse5'\n */\n\n/**\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport { ok as assert } from 'devlop';\nimport { h, s } from 'hastscript';\nimport { find, html, svg } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nconst own = {}.hasOwnProperty;\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype;\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {DefaultTreeAdapterMap['node']} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const settings = options || {};\n  return one({\n    file: settings.file || undefined,\n    location: false,\n    schema: settings.space === 'svg' ? svg : html,\n    verbose: settings.verbose || false\n  }, tree);\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  let result;\n  switch (node.nodeName) {\n    case '#comment':\n      {\n        const reference = /** @type {DefaultTreeAdapterMap['commentNode']} */\n        node;\n        result = {\n          type: 'comment',\n          value: reference.data\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    case '#document':\n    case '#document-fragment':\n      {\n        const reference = /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */\n        node;\n        const quirksMode = 'mode' in reference ? reference.mode === 'quirks' || reference.mode === 'limited-quirks' : false;\n        result = {\n          type: 'root',\n          children: all(state, node.childNodes),\n          data: {\n            quirksMode\n          }\n        };\n        if (state.file && state.location) {\n          const document = String(state.file);\n          const loc = location(document);\n          const start = loc.toPoint(0);\n          const end = loc.toPoint(document.length);\n          // Always defined as we give valid input.\n          assert(start, 'expected `start`');\n          assert(end, 'expected `end`');\n          result.position = {\n            start,\n            end\n          };\n        }\n        return result;\n      }\n    case '#documentType':\n      {\n        const reference = /** @type {DefaultTreeAdapterMap['documentType']} */\n        node;\n        result = {\n          type: 'doctype'\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    case '#text':\n      {\n        const reference = /** @type {DefaultTreeAdapterMap['textNode']} */node;\n        result = {\n          type: 'text',\n          value: reference.value\n        };\n        patch(state, reference, result);\n        return result;\n      }\n\n    // Element.\n    default:\n      {\n        const reference = /** @type {DefaultTreeAdapterMap['element']} */node;\n        result = element(state, reference);\n        return result;\n      }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<DefaultTreeAdapterMap['node']>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1;\n  /** @type {Array<RootContent>} */\n  const results = [];\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    const result = /** @type {RootContent} */one(state, nodes[index]);\n    results.push(result);\n  }\n  return results;\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['element']} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema;\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html;\n\n  // Props.\n  let index = -1;\n  /** @type {Record<string, string>} */\n  const properties = {};\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index];\n    const name = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;\n    if (!own.call(proto, name)) {\n      properties[name] = attribute.value;\n    }\n  }\n\n  // Build.\n  const x = state.schema.space === 'svg' ? s : h;\n  const result = x(node.tagName, properties, all(state, node.childNodes));\n  patch(state, node, result);\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {DefaultTreeAdapterMap['template']} */node;\n    const pos = reference.sourceCodeLocation;\n    const startTag = pos && pos.startTag && position(pos.startTag);\n    const endTag = pos && pos.endTag && position(pos.endTag);\n\n    // Root in, root out.\n    const content = /** @type {Root} */one(state, reference.content);\n    if (startTag && endTag && state.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n    result.content = content;\n  }\n  state.schema = schema;\n  return result;\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation);\n    if (position) {\n      state.location = true;\n      to.position = position;\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {Token.ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location);\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1];\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const properties = {};\n      /** @type {string} */\n      let key;\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            properties[find(state.schema, key).property] = position(location.attrs[key]);\n          }\n        }\n      }\n      assert(location.startTag, 'a start tag should exist');\n      const opening = position(location.startTag);\n      const closing = location.endTag ? position(location.endTag) : undefined;\n      /** @type {ElementData['position']} */\n      const data = {\n        opening\n      };\n      if (closing) data.closing = closing;\n      data.properties = properties;\n      node.data = {\n        position: data\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {Token.Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  });\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {\n    start,\n    end\n  } : undefined;\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined;\n}","map":{"version":3,"names":["ok","assert","h","s","find","html","svg","location","webNamespaces","own","hasOwnProperty","proto","Object","prototype","fromParse5","tree","options","settings","one","file","undefined","schema","space","verbose","state","node","result","nodeName","reference","type","value","data","patch","quirksMode","mode","children","all","childNodes","document","String","loc","start","toPoint","end","length","position","element","nodes","index","results","push","namespaceURI","properties","attrs","attribute","name","prefix","call","x","tagName","pos","sourceCodeLocation","startTag","endTag","content","from","to","createLocation","tail","assign","key","property","opening","closing","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"sources":["C:/Users/Owner/certifystack/node_modules/hast-util-from-parse5/lib/index.js"],"sourcesContent":["/**\n * @import {ElementData, Element, Nodes, RootContent, Root} from 'hast'\n * @import {DefaultTreeAdapterMap, Token} from 'parse5'\n * @import {Schema} from 'property-information'\n * @import {Point, Position} from 'unist'\n * @import {VFile} from 'vfile'\n * @import {Options} from 'hast-util-from-parse5'\n */\n\n/**\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport {ok as assert} from 'devlop'\nimport {h, s} from 'hastscript'\nimport {find, html, svg} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {DefaultTreeAdapterMap['node']} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const settings = options || {}\n\n  return one(\n    {\n      file: settings.file || undefined,\n      location: false,\n      schema: settings.space === 'svg' ? svg : html,\n      verbose: settings.verbose || false\n    },\n    tree\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  let result\n\n  switch (node.nodeName) {\n    case '#comment': {\n      const reference = /** @type {DefaultTreeAdapterMap['commentNode']} */ (\n        node\n      )\n      result = {type: 'comment', value: reference.data}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#document':\n    case '#document-fragment': {\n      const reference =\n        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */ (\n          node\n        )\n      const quirksMode =\n        'mode' in reference\n          ? reference.mode === 'quirks' || reference.mode === 'limited-quirks'\n          : false\n\n      result = {\n        type: 'root',\n        children: all(state, node.childNodes),\n        data: {quirksMode}\n      }\n\n      if (state.file && state.location) {\n        const document = String(state.file)\n        const loc = location(document)\n        const start = loc.toPoint(0)\n        const end = loc.toPoint(document.length)\n        // Always defined as we give valid input.\n        assert(start, 'expected `start`')\n        assert(end, 'expected `end`')\n        result.position = {start, end}\n      }\n\n      return result\n    }\n\n    case '#documentType': {\n      const reference = /** @type {DefaultTreeAdapterMap['documentType']} */ (\n        node\n      )\n      result = {type: 'doctype'}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#text': {\n      const reference = /** @type {DefaultTreeAdapterMap['textNode']} */ (node)\n      result = {type: 'text', value: reference.value}\n      patch(state, reference, result)\n      return result\n    }\n\n    // Element.\n    default: {\n      const reference = /** @type {DefaultTreeAdapterMap['element']} */ (node)\n      result = element(state, reference)\n      return result\n    }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<DefaultTreeAdapterMap['node']>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1\n  /** @type {Array<RootContent>} */\n  const results = []\n\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    const result = /** @type {RootContent} */ (one(state, nodes[index]))\n    results.push(result)\n  }\n\n  return results\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['element']} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema\n\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html\n\n  // Props.\n  let index = -1\n  /** @type {Record<string, string>} */\n  const properties = {}\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index]\n    const name =\n      (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name\n    if (!own.call(proto, name)) {\n      properties[name] = attribute.value\n    }\n  }\n\n  // Build.\n  const x = state.schema.space === 'svg' ? s : h\n  const result = x(node.tagName, properties, all(state, node.childNodes))\n  patch(state, node, result)\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {DefaultTreeAdapterMap['template']} */ (node)\n    const pos = reference.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    // Root in, root out.\n    const content = /** @type {Root} */ (one(state, reference.content))\n\n    if (startTag && endTag && state.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  state.schema = schema\n\n  return result\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation)\n\n    if (position) {\n      state.location = true\n      to.position = position\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {Token.ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const properties = {}\n      /** @type {string} */\n      let key\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            properties[find(state.schema, key).property] = position(\n              location.attrs[key]\n            )\n          }\n        }\n      }\n\n      assert(location.startTag, 'a start tag should exist')\n      const opening = position(location.startTag)\n      const closing = location.endTag ? position(location.endTag) : undefined\n      /** @type {ElementData['position']} */\n      const data = {opening}\n      if (closing) data.closing = closing\n      data.properties = properties\n\n      node.data = {position: data}\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {Token.Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {start, end} : undefined\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}